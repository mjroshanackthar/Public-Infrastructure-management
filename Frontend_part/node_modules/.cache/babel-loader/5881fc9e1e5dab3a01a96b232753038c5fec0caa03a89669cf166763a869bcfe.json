{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\locha\\\\Downloads\\\\BC_Backend_part\\\\Frontend_part\\\\src\\\\contexts\\\\Web3Context.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\n\n// Try to import Web3 dependencies, fallback if not available\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nlet ethers, detectEthereumProvider;\nlet WEB3_AVAILABLE = false;\ntry {\n  ethers = require('ethers');\n  detectEthereumProvider = require('@metamask/detect-provider').default;\n  WEB3_AVAILABLE = true;\n} catch (error) {\n  console.warn('Web3 dependencies not available. Install with: npm install ethers @metamask/detect-provider');\n  // Fallback implementations\n  ethers = {\n    BrowserProvider: class {\n      constructor() {\n        throw new Error('ethers not available');\n      }\n    },\n    Contract: class {\n      constructor() {\n        throw new Error('ethers not available');\n      }\n    },\n    parseEther: () => {\n      throw new Error('ethers not available');\n    },\n    formatEther: () => {\n      throw new Error('ethers not available');\n    }\n  };\n  detectEthereumProvider = () => Promise.resolve(null);\n}\nconst Web3Context = /*#__PURE__*/createContext();\nexport const useWeb3 = () => {\n  _s();\n  const context = useContext(Web3Context);\n  if (!context) {\n    throw new Error('useWeb3 must be used within a Web3Provider');\n  }\n  return context;\n};\n_s(useWeb3, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport const Web3Provider = ({\n  children\n}) => {\n  _s2();\n  const [provider, setProvider] = useState(null);\n  const [signer, setSigner] = useState(null);\n  const [account, setAccount] = useState(null);\n  const [chainId, setChainId] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [contracts, setContracts] = useState({});\n\n  // Contract addresses and ABIs (you'll need to update these with your actual contract addresses)\n  const CONTRACT_ADDRESSES = {\n    TenderManagement: '0x5FbDB2315678afecb367f032d93F642f64180aa3',\n    CredentialVerification: '0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512',\n    ContractorRegistry: '0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0'\n  };\n\n  // Basic contract ABIs (you'll need to update these with your actual ABIs)\n  const CONTRACT_ABIS = {\n    TenderManagement: [\"function createTender(string memory title, string memory description, uint256 budget, uint256 deadline, uint256 minQualificationScore, uint256 maxBids) external\", \"function submitBid(uint256 tenderId, uint256 amount, uint256 estimatedDuration, string memory proposal) external\", \"function assignWinner(uint256 tenderId, uint256 bidId) external\", \"function getTender(uint256 tenderId) external view returns (tuple(string title, string description, uint256 budget, uint256 deadline, uint256 minQualificationScore, uint256 maxBids, uint8 status, address creator, uint256 bidCount))\", \"function getTenderBids(uint256 tenderId) external view returns (tuple(address bidder, uint256 amount, uint256 estimatedDuration, string proposal, uint256 timestamp)[])\", \"function getTenderCount() external view returns (uint256)\", \"event TenderCreated(uint256 indexed tenderId, address indexed creator, string title, uint256 budget)\", \"event BidSubmitted(uint256 indexed tenderId, address indexed bidder, uint256 amount)\", \"event WinnerAssigned(uint256 indexed tenderId, address indexed winner, uint256 amount)\"],\n    CredentialVerification: [\"function addCredential(string memory certificateType, string memory certificateHash, string memory issuer, uint256 expiryDays) external\", \"function verifyCredential(address user, string memory certificateType) external\", \"function getCredentialStatus(address user, string memory certificateType) external view returns (bool exists, bool isVerified, uint256 verificationCount, uint256 requiredVerifications)\", \"function addVerifier(address verifier) external\", \"function getVerifiers() external view returns (address[])\", \"event CredentialAdded(address indexed user, string certificateType, string issuer)\", \"event CredentialVerified(address indexed user, string certificateType, address indexed verifier)\"],\n    ContractorRegistry: [\"function registerContractor() external\", \"function getContractorInfo(address contractor) external view returns (bool isRegistered, bool isVerified, uint256 totalBids, uint256 wonBids)\", \"function getAllContractors() external view returns (address[])\", \"event ContractorRegistered(address indexed contractor)\", \"event ContractorVerified(address indexed contractor)\"]\n  };\n\n  // Initialize Web3 connection\n  const initializeWeb3 = async () => {\n    if (!WEB3_AVAILABLE) {\n      setError('Web3 dependencies not installed. Please run: npm install ethers @metamask/detect-provider');\n      return;\n    }\n    try {\n      setIsLoading(true);\n      setError(null);\n      const ethereumProvider = await detectEthereumProvider();\n      if (!ethereumProvider) {\n        setError('MetaMask not detected. Please install MetaMask browser extension.');\n        return;\n      }\n      const web3Provider = new ethers.BrowserProvider(ethereumProvider);\n      setProvider(web3Provider);\n\n      // Get network info\n      const network = await web3Provider.getNetwork();\n      setChainId(Number(network.chainId));\n\n      // Check if already connected\n      const accounts = await ethereumProvider.request({\n        method: 'eth_accounts'\n      });\n      if (accounts.length > 0) {\n        await connectWallet();\n      }\n\n      // Listen for account changes\n      ethereumProvider.on('accountsChanged', handleAccountsChanged);\n      ethereumProvider.on('chainChanged', handleChainChanged);\n    } catch (err) {\n      setError(err.message);\n      console.error('Web3 initialization error:', err);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Connect wallet\n  const connectWallet = async () => {\n    if (!WEB3_AVAILABLE) {\n      setError('Web3 dependencies not available');\n      return;\n    }\n    try {\n      setIsLoading(true);\n      setError(null);\n      if (!provider) {\n        await initializeWeb3();\n        return;\n      }\n      const accounts = await window.ethereum.request({\n        method: 'eth_requestAccounts'\n      });\n      if (accounts.length > 0) {\n        const userSigner = await provider.getSigner();\n        setSigner(userSigner);\n        setAccount(accounts[0]);\n        setIsConnected(true);\n\n        // Initialize contracts\n        await initializeContracts(userSigner);\n      }\n    } catch (err) {\n      setError(err.message);\n      console.error('Wallet connection error:', err);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Initialize smart contracts\n  const initializeContracts = async userSigner => {\n    if (!WEB3_AVAILABLE) return;\n    try {\n      const contractInstances = {};\n      for (const [name, address] of Object.entries(CONTRACT_ADDRESSES)) {\n        if (CONTRACT_ABIS[name]) {\n          contractInstances[name] = new ethers.Contract(address, CONTRACT_ABIS[name], userSigner);\n        }\n      }\n      setContracts(contractInstances);\n    } catch (err) {\n      console.error('Contract initialization error:', err);\n    }\n  };\n\n  // Disconnect wallet\n  const disconnectWallet = () => {\n    setProvider(null);\n    setSigner(null);\n    setAccount(null);\n    setIsConnected(false);\n    setContracts({});\n  };\n\n  // Handle account changes\n  const handleAccountsChanged = accounts => {\n    if (accounts.length === 0) {\n      disconnectWallet();\n    } else {\n      setAccount(accounts[0]);\n    }\n  };\n\n  // Handle chain changes\n  const handleChainChanged = chainId => {\n    setChainId(parseInt(chainId, 16));\n    window.location.reload(); // Reload to reset state\n  };\n\n  // Switch to local network (Hardhat)\n  const switchToLocalNetwork = async () => {\n    if (!WEB3_AVAILABLE || !window.ethereum) {\n      setError('MetaMask not available');\n      return;\n    }\n    try {\n      await window.ethereum.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{\n          chainId: '0x7A69'\n        }] // 31337 in hex (Hardhat default)\n      });\n    } catch (switchError) {\n      // If network doesn't exist, add it\n      if (switchError.code === 4902) {\n        try {\n          await window.ethereum.request({\n            method: 'wallet_addEthereumChain',\n            params: [{\n              chainId: '0x7A69',\n              chainName: 'Hardhat Local',\n              nativeCurrency: {\n                name: 'ETH',\n                symbol: 'ETH',\n                decimals: 18\n              },\n              rpcUrls: ['http://127.0.0.1:8545'],\n              blockExplorerUrls: null\n            }]\n          });\n        } catch (addError) {\n          console.error('Failed to add network:', addError);\n        }\n      }\n    }\n  };\n\n  // Get account balance\n  const getBalance = async (address = account) => {\n    if (!WEB3_AVAILABLE || !provider || !address) return '0';\n    try {\n      const balance = await provider.getBalance(address);\n      return ethers.formatEther(balance);\n    } catch (err) {\n      console.error('Balance fetch error:', err);\n      return '0';\n    }\n  };\n\n  // Format address for display\n  const formatAddress = address => {\n    if (!address) return '';\n    return `${address.slice(0, 6)}...${address.slice(-4)}`;\n  };\n\n  // Check if on correct network (Hardhat local)\n  const isCorrectNetwork = () => {\n    return chainId === 31337; // Hardhat default chain ID\n  };\n  useEffect(() => {\n    if (WEB3_AVAILABLE) {\n      initializeWeb3();\n    } else {\n      setError('Web3 dependencies not installed. Run: npm install ethers @metamask/detect-provider');\n    }\n  }, []);\n  const value = {\n    // State\n    provider,\n    signer,\n    account,\n    chainId,\n    isConnected,\n    isLoading,\n    error,\n    contracts,\n    web3Available: WEB3_AVAILABLE,\n    // Actions\n    connectWallet,\n    disconnectWallet,\n    switchToLocalNetwork,\n    getBalance,\n    formatAddress,\n    isCorrectNetwork,\n    // Contract addresses for reference\n    CONTRACT_ADDRESSES\n  };\n  return /*#__PURE__*/_jsxDEV(Web3Context.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 303,\n    columnNumber: 5\n  }, this);\n};\n_s2(Web3Provider, \"IdphvAQF+gBTgglPUExj3ECZjWM=\");\n_c = Web3Provider;\nvar _c;\n$RefreshReg$(_c, \"Web3Provider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","jsxDEV","_jsxDEV","ethers","detectEthereumProvider","WEB3_AVAILABLE","require","default","error","console","warn","BrowserProvider","constructor","Error","Contract","parseEther","formatEther","Promise","resolve","Web3Context","useWeb3","_s","context","Web3Provider","children","_s2","provider","setProvider","signer","setSigner","account","setAccount","chainId","setChainId","isConnected","setIsConnected","isLoading","setIsLoading","setError","contracts","setContracts","CONTRACT_ADDRESSES","TenderManagement","CredentialVerification","ContractorRegistry","CONTRACT_ABIS","initializeWeb3","ethereumProvider","web3Provider","network","getNetwork","Number","accounts","request","method","length","connectWallet","on","handleAccountsChanged","handleChainChanged","err","message","window","ethereum","userSigner","getSigner","initializeContracts","contractInstances","name","address","Object","entries","disconnectWallet","parseInt","location","reload","switchToLocalNetwork","params","switchError","code","chainName","nativeCurrency","symbol","decimals","rpcUrls","blockExplorerUrls","addError","getBalance","balance","formatAddress","slice","isCorrectNetwork","value","web3Available","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/locha/Downloads/BC_Backend_part/Frontend_part/src/contexts/Web3Context.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\r\n\r\n// Try to import Web3 dependencies, fallback if not available\r\nlet ethers, detectEthereumProvider;\r\nlet WEB3_AVAILABLE = false;\r\n\r\ntry {\r\n  ethers = require('ethers');\r\n  detectEthereumProvider = require('@metamask/detect-provider').default;\r\n  WEB3_AVAILABLE = true;\r\n} catch (error) {\r\n  console.warn('Web3 dependencies not available. Install with: npm install ethers @metamask/detect-provider');\r\n  // Fallback implementations\r\n  ethers = {\r\n    BrowserProvider: class { constructor() { throw new Error('ethers not available'); } },\r\n    Contract: class { constructor() { throw new Error('ethers not available'); } },\r\n    parseEther: () => { throw new Error('ethers not available'); },\r\n    formatEther: () => { throw new Error('ethers not available'); }\r\n  };\r\n  detectEthereumProvider = () => Promise.resolve(null);\r\n}\r\n\r\nconst Web3Context = createContext();\r\n\r\nexport const useWeb3 = () => {\r\n  const context = useContext(Web3Context);\r\n  if (!context) {\r\n    throw new Error('useWeb3 must be used within a Web3Provider');\r\n  }\r\n  return context;\r\n};\r\n\r\nexport const Web3Provider = ({ children }) => {\r\n  const [provider, setProvider] = useState(null);\r\n  const [signer, setSigner] = useState(null);\r\n  const [account, setAccount] = useState(null);\r\n  const [chainId, setChainId] = useState(null);\r\n  const [isConnected, setIsConnected] = useState(false);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [error, setError] = useState(null);\r\n  const [contracts, setContracts] = useState({});\r\n\r\n  // Contract addresses and ABIs (you'll need to update these with your actual contract addresses)\r\n  const CONTRACT_ADDRESSES = {\r\n    TenderManagement: '0x5FbDB2315678afecb367f032d93F642f64180aa3',\r\n    CredentialVerification: '0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512',\r\n    ContractorRegistry: '0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0'\r\n  };\r\n\r\n  // Basic contract ABIs (you'll need to update these with your actual ABIs)\r\n  const CONTRACT_ABIS = {\r\n    TenderManagement: [\r\n      \"function createTender(string memory title, string memory description, uint256 budget, uint256 deadline, uint256 minQualificationScore, uint256 maxBids) external\",\r\n      \"function submitBid(uint256 tenderId, uint256 amount, uint256 estimatedDuration, string memory proposal) external\",\r\n      \"function assignWinner(uint256 tenderId, uint256 bidId) external\",\r\n      \"function getTender(uint256 tenderId) external view returns (tuple(string title, string description, uint256 budget, uint256 deadline, uint256 minQualificationScore, uint256 maxBids, uint8 status, address creator, uint256 bidCount))\",\r\n      \"function getTenderBids(uint256 tenderId) external view returns (tuple(address bidder, uint256 amount, uint256 estimatedDuration, string proposal, uint256 timestamp)[])\",\r\n      \"function getTenderCount() external view returns (uint256)\",\r\n      \"event TenderCreated(uint256 indexed tenderId, address indexed creator, string title, uint256 budget)\",\r\n      \"event BidSubmitted(uint256 indexed tenderId, address indexed bidder, uint256 amount)\",\r\n      \"event WinnerAssigned(uint256 indexed tenderId, address indexed winner, uint256 amount)\"\r\n    ],\r\n    CredentialVerification: [\r\n      \"function addCredential(string memory certificateType, string memory certificateHash, string memory issuer, uint256 expiryDays) external\",\r\n      \"function verifyCredential(address user, string memory certificateType) external\",\r\n      \"function getCredentialStatus(address user, string memory certificateType) external view returns (bool exists, bool isVerified, uint256 verificationCount, uint256 requiredVerifications)\",\r\n      \"function addVerifier(address verifier) external\",\r\n      \"function getVerifiers() external view returns (address[])\",\r\n      \"event CredentialAdded(address indexed user, string certificateType, string issuer)\",\r\n      \"event CredentialVerified(address indexed user, string certificateType, address indexed verifier)\"\r\n    ],\r\n    ContractorRegistry: [\r\n      \"function registerContractor() external\",\r\n      \"function getContractorInfo(address contractor) external view returns (bool isRegistered, bool isVerified, uint256 totalBids, uint256 wonBids)\",\r\n      \"function getAllContractors() external view returns (address[])\",\r\n      \"event ContractorRegistered(address indexed contractor)\",\r\n      \"event ContractorVerified(address indexed contractor)\"\r\n    ]\r\n  };\r\n\r\n  // Initialize Web3 connection\r\n  const initializeWeb3 = async () => {\r\n    if (!WEB3_AVAILABLE) {\r\n      setError('Web3 dependencies not installed. Please run: npm install ethers @metamask/detect-provider');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      setIsLoading(true);\r\n      setError(null);\r\n\r\n      const ethereumProvider = await detectEthereumProvider();\r\n      \r\n      if (!ethereumProvider) {\r\n        setError('MetaMask not detected. Please install MetaMask browser extension.');\r\n        return;\r\n      }\r\n\r\n      const web3Provider = new ethers.BrowserProvider(ethereumProvider);\r\n      setProvider(web3Provider);\r\n\r\n      // Get network info\r\n      const network = await web3Provider.getNetwork();\r\n      setChainId(Number(network.chainId));\r\n\r\n      // Check if already connected\r\n      const accounts = await ethereumProvider.request({ method: 'eth_accounts' });\r\n      if (accounts.length > 0) {\r\n        await connectWallet();\r\n      }\r\n\r\n      // Listen for account changes\r\n      ethereumProvider.on('accountsChanged', handleAccountsChanged);\r\n      ethereumProvider.on('chainChanged', handleChainChanged);\r\n\r\n    } catch (err) {\r\n      setError(err.message);\r\n      console.error('Web3 initialization error:', err);\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  // Connect wallet\r\n  const connectWallet = async () => {\r\n    if (!WEB3_AVAILABLE) {\r\n      setError('Web3 dependencies not available');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      setIsLoading(true);\r\n      setError(null);\r\n\r\n      if (!provider) {\r\n        await initializeWeb3();\r\n        return;\r\n      }\r\n\r\n      const accounts = await window.ethereum.request({\r\n        method: 'eth_requestAccounts',\r\n      });\r\n\r\n      if (accounts.length > 0) {\r\n        const userSigner = await provider.getSigner();\r\n        setSigner(userSigner);\r\n        setAccount(accounts[0]);\r\n        setIsConnected(true);\r\n\r\n        // Initialize contracts\r\n        await initializeContracts(userSigner);\r\n      }\r\n    } catch (err) {\r\n      setError(err.message);\r\n      console.error('Wallet connection error:', err);\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  // Initialize smart contracts\r\n  const initializeContracts = async (userSigner) => {\r\n    if (!WEB3_AVAILABLE) return;\r\n\r\n    try {\r\n      const contractInstances = {};\r\n\r\n      for (const [name, address] of Object.entries(CONTRACT_ADDRESSES)) {\r\n        if (CONTRACT_ABIS[name]) {\r\n          contractInstances[name] = new ethers.Contract(\r\n            address,\r\n            CONTRACT_ABIS[name],\r\n            userSigner\r\n          );\r\n        }\r\n      }\r\n\r\n      setContracts(contractInstances);\r\n    } catch (err) {\r\n      console.error('Contract initialization error:', err);\r\n    }\r\n  };\r\n\r\n  // Disconnect wallet\r\n  const disconnectWallet = () => {\r\n    setProvider(null);\r\n    setSigner(null);\r\n    setAccount(null);\r\n    setIsConnected(false);\r\n    setContracts({});\r\n  };\r\n\r\n  // Handle account changes\r\n  const handleAccountsChanged = (accounts) => {\r\n    if (accounts.length === 0) {\r\n      disconnectWallet();\r\n    } else {\r\n      setAccount(accounts[0]);\r\n    }\r\n  };\r\n\r\n  // Handle chain changes\r\n  const handleChainChanged = (chainId) => {\r\n    setChainId(parseInt(chainId, 16));\r\n    window.location.reload(); // Reload to reset state\r\n  };\r\n\r\n  // Switch to local network (Hardhat)\r\n  const switchToLocalNetwork = async () => {\r\n    if (!WEB3_AVAILABLE || !window.ethereum) {\r\n      setError('MetaMask not available');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      await window.ethereum.request({\r\n        method: 'wallet_switchEthereumChain',\r\n        params: [{ chainId: '0x7A69' }], // 31337 in hex (Hardhat default)\r\n      });\r\n    } catch (switchError) {\r\n      // If network doesn't exist, add it\r\n      if (switchError.code === 4902) {\r\n        try {\r\n          await window.ethereum.request({\r\n            method: 'wallet_addEthereumChain',\r\n            params: [\r\n              {\r\n                chainId: '0x7A69',\r\n                chainName: 'Hardhat Local',\r\n                nativeCurrency: {\r\n                  name: 'ETH',\r\n                  symbol: 'ETH',\r\n                  decimals: 18,\r\n                },\r\n                rpcUrls: ['http://127.0.0.1:8545'],\r\n                blockExplorerUrls: null,\r\n              },\r\n            ],\r\n          });\r\n        } catch (addError) {\r\n          console.error('Failed to add network:', addError);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  // Get account balance\r\n  const getBalance = async (address = account) => {\r\n    if (!WEB3_AVAILABLE || !provider || !address) return '0';\r\n    try {\r\n      const balance = await provider.getBalance(address);\r\n      return ethers.formatEther(balance);\r\n    } catch (err) {\r\n      console.error('Balance fetch error:', err);\r\n      return '0';\r\n    }\r\n  };\r\n\r\n  // Format address for display\r\n  const formatAddress = (address) => {\r\n    if (!address) return '';\r\n    return `${address.slice(0, 6)}...${address.slice(-4)}`;\r\n  };\r\n\r\n  // Check if on correct network (Hardhat local)\r\n  const isCorrectNetwork = () => {\r\n    return chainId === 31337; // Hardhat default chain ID\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (WEB3_AVAILABLE) {\r\n      initializeWeb3();\r\n    } else {\r\n      setError('Web3 dependencies not installed. Run: npm install ethers @metamask/detect-provider');\r\n    }\r\n  }, []);\r\n\r\n  const value = {\r\n    // State\r\n    provider,\r\n    signer,\r\n    account,\r\n    chainId,\r\n    isConnected,\r\n    isLoading,\r\n    error,\r\n    contracts,\r\n    web3Available: WEB3_AVAILABLE,\r\n\r\n    // Actions\r\n    connectWallet,\r\n    disconnectWallet,\r\n    switchToLocalNetwork,\r\n    getBalance,\r\n    formatAddress,\r\n    isCorrectNetwork,\r\n\r\n    // Contract addresses for reference\r\n    CONTRACT_ADDRESSES,\r\n  };\r\n\r\n  return (\r\n    <Web3Context.Provider value={value}>\r\n      {children}\r\n    </Web3Context.Provider>\r\n  );\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}